{"ast":null,"code":"import _slicedToArray from \"/Users/utils/misc/alexnicita.github.io/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/utils/misc/alexnicita.github.io/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/Users/utils/misc/alexnicita.github.io/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _jsxFileName = \"/Users/utils/misc/alexnicita.github.io/src/WinXP/apps/Minesweeper/index.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { useReducer, useEffect, useState } from 'react';\nimport sampleSize from 'lodash.samplesize';\nimport { Config } from './config';\nimport MinesweeperView from './MinesweeperView';\n\n// state: {\n//   difficulty: 'Beginner' || 'Intermediate' || 'Expert',\n//   status: 'new' || 'started' || 'died' || 'won',\n//   rows: Number,\n//   columns: Number,\n//   mines: Number,\n//   ceils: Array {\n//     state: 'cover' || 'flag' || 'unknown' || 'open' || 'die' || 'misflagged',\n//     minesAround: Number (negative for mine itself),\n//     opening: true || false\n//   }\n// }\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction getInitState() {\n  var difficulty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Beginner';\n  return _objectSpread({\n    difficulty: difficulty,\n    status: 'new'\n  }, genGameConfig(Config[difficulty]));\n}\nfunction reducer(state) {\n  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  switch (action.type) {\n    case 'CLEAR_MAP':\n      var difficulty = action.payload || state.difficulty;\n      return getInitState(difficulty);\n    case 'START_GAME':\n      var exclude = action.payload;\n      return _objectSpread(_objectSpread(_objectSpread({}, state), insertMines(_objectSpread(_objectSpread({}, Config[state.difficulty]), {}, {\n        exclude: exclude\n      }), state.ceils)), {}, {\n        status: 'started'\n      });\n    case 'OPEN_CEIL':\n      {\n        var indexes = autoCeils(state, action.payload);\n        var ceils = _toConsumableArray(state.ceils);\n        indexes.forEach(function (i) {\n          var ceil = ceils[i];\n          ceils[i] = _objectSpread(_objectSpread({}, ceil), {}, {\n            state: 'open'\n          });\n        });\n        return _objectSpread(_objectSpread({}, state), {}, {\n          ceils: ceils\n        });\n      }\n    case 'CHANGE_CEIL_STATE':\n      {\n        var index = action.payload;\n        var _ceils = _toConsumableArray(state.ceils);\n        var ceil = state.ceils[index];\n        var newState;\n        switch (ceil.state) {\n          case 'cover':\n            newState = 'flag';\n            break;\n          case 'flag':\n            newState = 'unknown';\n            break;\n          case 'unknown':\n            newState = 'cover';\n            break;\n          default:\n            throw new Error(\"Unknown ceil state \".concat(ceil.state));\n        }\n        _ceils[index] = _objectSpread(_objectSpread({}, ceil), {}, {\n          state: newState\n        });\n        return _objectSpread(_objectSpread({}, state), {}, {\n          ceils: _ceils\n        });\n      }\n    case 'GAME_OVER':\n      {\n        var _ceils2 = state.ceils.map(function (ceil) {\n          if (ceil.minesAround < 0 && ceil.state !== 'flag') {\n            return _objectSpread(_objectSpread({}, ceil), {}, {\n              state: 'mine'\n            });\n          } else if (ceil.state === 'flag' && ceil.minesAround >= 0) {\n            return _objectSpread(_objectSpread({}, ceil), {}, {\n              state: 'misflagged'\n            });\n          } else {\n            return _objectSpread(_objectSpread({}, ceil), {}, {\n              opening: false\n            });\n          }\n        });\n        _ceils2[action.payload].state = 'die';\n        return _objectSpread(_objectSpread({}, state), {}, {\n          status: 'died',\n          ceils: _ceils2\n        });\n      }\n    case 'WON':\n      {\n        var _ceils3 = state.ceils.map(function (ceil) {\n          if (ceil.minesAround >= 0) {\n            return _objectSpread(_objectSpread({}, ceil), {}, {\n              state: 'open'\n            });\n          } else {\n            return _objectSpread(_objectSpread({}, ceil), {}, {\n              state: 'flag'\n            });\n          }\n        });\n        return _objectSpread(_objectSpread({}, state), {}, {\n          status: 'won',\n          ceils: _ceils3\n        });\n      }\n    case 'OPENING_CEIL':\n      {\n        var _ceil = state.ceils[action.payload];\n        var _ceils4 = state.ceils.map(function (ceil) {\n          return _objectSpread(_objectSpread({}, ceil), {}, {\n            opening: false\n          });\n        });\n        _ceils4[action.payload] = _objectSpread(_objectSpread({}, _ceil), {}, {\n          opening: true\n        });\n        return _objectSpread(_objectSpread({}, state), {}, {\n          ceils: _ceils4\n        });\n      }\n    case 'OPENING_CEILS':\n      {\n        var _indexes = getNearIndexes(action.payload, state.rows, state.columns);\n        var _ceils5 = state.ceils.map(function (ceil) {\n          return _objectSpread(_objectSpread({}, ceil), {}, {\n            opening: false\n          });\n        });\n        [].concat(_toConsumableArray(_indexes), [action.payload]).forEach(function (index) {\n          var ceil = _objectSpread({}, _ceils5[index]);\n          ceil.opening = true;\n          _ceils5[index] = ceil;\n        });\n        return _objectSpread(_objectSpread({}, state), {}, {\n          ceils: _ceils5\n        });\n      }\n    default:\n      return state;\n  }\n}\nfunction MineSweeper(_ref) {\n  _s();\n  var defaultDifficulty = _ref.defaultDifficulty,\n    onClose = _ref.onClose;\n  var _useReducer = useReducer(reducer, getInitState(defaultDifficulty)),\n    _useReducer2 = _slicedToArray(_useReducer, 2),\n    state = _useReducer2[0],\n    dispatch = _useReducer2[1];\n  var seconds = useTimer(state.status);\n  function changeCeilState(index) {\n    var ceil = state.ceils[index];\n    if (ceil.state === 'open' || ['won', 'died'].includes(state.status)) return;\n    dispatch({\n      type: 'CHANGE_CEIL_STATE',\n      payload: index\n    });\n  }\n  function openCeil(index) {\n    switch (state.status) {\n      case 'new':\n        dispatch({\n          type: 'START_GAME',\n          payload: index\n        });\n        dispatch({\n          type: 'OPEN_CEIL',\n          payload: index\n        });\n        break;\n      case 'started':\n        var ceil = state.ceils[index];\n        if (['flag', 'open'].includes(ceil.state)) {\n          break;\n        } else if (ceil.minesAround < 0) {\n          dispatch({\n            type: 'GAME_OVER',\n            payload: index\n          });\n        } else {\n          dispatch({\n            type: 'OPEN_CEIL',\n            payload: index\n          });\n        }\n        break;\n      default:\n      // console.log(state.status);\n    }\n  }\n\n  function openCeils(index) {\n    var ceil = state.ceils[index];\n    if (ceil.state !== 'open' || ceil.minesAround <= 0 || state.status !== 'started') return;\n    var indexes = getNearIndexes(index, state.rows, state.columns);\n    var nearCeils = indexes.map(function (i) {\n      return state.ceils[i];\n    });\n    if (nearCeils.filter(function (ceil) {\n      return ceil.state === 'flag';\n    }).length !== ceil.minesAround) return;\n    var mineIndex = indexes.find(function (i) {\n      return state.ceils[i].minesAround < 0 && state.ceils[i].state !== 'flag';\n    });\n    if (mineIndex) {\n      dispatch({\n        type: 'GAME_OVER',\n        payload: mineIndex\n      });\n    } else {\n      indexes.forEach(function (i) {\n        return dispatch({\n          type: 'OPEN_CEIL',\n          payload: i\n        });\n      });\n    }\n  }\n  useEffect(function () {\n    if (state.status === 'started' && checkRemains() === 0) {\n      dispatch({\n        type: 'WON'\n      });\n    }\n  });\n  function onReset(difficulty) {\n    dispatch({\n      type: 'CLEAR_MAP',\n      payload: difficulty\n    });\n  }\n  function checkRemains() {\n    var safeCeils = state.ceils.filter(function (ceil) {\n      return ceil.state !== 'open';\n    }).filter(function (ceil) {\n      return ceil.minesAround >= 0;\n    });\n    return safeCeils.length;\n  }\n  function openingCeil(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({\n      type: 'OPENING_CEIL',\n      payload: index\n    });\n  }\n  function openingCeils(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({\n      type: 'OPENING_CEILS',\n      payload: index\n    });\n  }\n  return /*#__PURE__*/_jsxDEV(MinesweeperView, _objectSpread(_objectSpread({}, state), {}, {\n    onClose: onClose,\n    changeCeilState: changeCeilState,\n    openCeil: openCeil,\n    openCeils: openCeils,\n    onReset: onReset,\n    seconds: seconds,\n    openingCeil: openingCeil,\n    openingCeils: openingCeils\n  }), void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 233,\n    columnNumber: 5\n  }, this);\n}\n_s(MineSweeper, \"2+64J9pulBICyo8Uc+tbwYBe/tE=\", false, function () {\n  return [useTimer];\n});\n_c = MineSweeper;\nfunction genGameConfig(config) {\n  var rows = config.rows,\n    columns = config.columns,\n    mines = config.mines;\n  var ceils = Array(rows * columns).fill().map(function (_) {\n    return {\n      state: 'cover',\n      minesAround: 0,\n      opening: false\n    };\n  });\n  return {\n    rows: rows,\n    columns: columns,\n    ceils: ceils,\n    mines: mines\n  };\n}\nfunction insertMines(config, originCeils) {\n  var rows = config.rows,\n    columns = config.columns,\n    mines = config.mines,\n    exclude = config.exclude;\n  var ceils = originCeils.map(function (ceil) {\n    return _objectSpread({}, ceil);\n  });\n  if (rows * columns !== ceils.length) throw new Error('rows and columns not equal to ceils');\n  var indexArray = _toConsumableArray(Array(rows * columns).keys());\n  sampleSize(indexArray.filter(function (i) {\n    return i !== exclude;\n  }), mines).forEach(function (chosen) {\n    ceils[chosen].minesAround = -10;\n    getNearIndexes(chosen, rows, columns).forEach(function (nearIndex) {\n      ceils[nearIndex].minesAround += 1;\n    });\n  });\n  return {\n    rows: rows,\n    columns: columns,\n    ceils: ceils,\n    mines: mines\n  };\n}\nfunction autoCeils(state, index) {\n  var rows = state.rows,\n    columns = state.columns;\n  var ceils = state.ceils.map(function (ceil) {\n    return _objectSpread(_objectSpread({}, ceil), {}, {\n      walked: false\n    });\n  });\n  return walkCeils(index);\n  function walkCeils(index) {\n    var ceil = ceils[index];\n    if (ceil.walked || ceil.minesAround < 0 || ceil.state === 'flag') return [];\n    ceil.walked = true;\n    if (ceil.minesAround > 0) return [index];\n    return [index].concat(_toConsumableArray(getNearIndexes(index, rows, columns).reduce(function (lastIndexes, ceilIndex) {\n      return [].concat(_toConsumableArray(lastIndexes), _toConsumableArray(walkCeils(ceilIndex)));\n    }, [])));\n  }\n}\nfunction getNearIndexes(index, rows, columns) {\n  if (index < 0 || index >= rows * columns) return [];\n  var row = Math.floor(index / columns);\n  var column = index % columns;\n  return [index - columns - 1, index - columns, index - columns + 1, index - 1, index + 1, index + columns - 1, index + columns, index + columns + 1].filter(function (_, arrayIndex) {\n    if (row === 0 && arrayIndex < 3) return false;\n    if (row === rows - 1 && arrayIndex > 4) return false;\n    if (column === 0 && [0, 3, 5].includes(arrayIndex)) return false;\n    if (column === columns - 1 && [2, 4, 7].includes(arrayIndex)) return false;\n    return true;\n  });\n}\nfunction useTimer(status) {\n  _s2();\n  var _useState = useState(0),\n    _useState2 = _slicedToArray(_useState, 2),\n    seconds = _useState2[0],\n    setSeconds = _useState2[1];\n  function addSecond() {\n    setSeconds(function (sec) {\n      return sec + 1;\n    });\n  }\n  useEffect(function () {\n    var timer;\n    switch (status) {\n      case 'started':\n        timer = setInterval(addSecond, 1000);\n        break;\n      case 'new':\n        setSeconds(0);\n        break;\n      default:\n        break;\n    }\n    return function () {\n      return clearInterval(timer);\n    };\n  }, [status]);\n  return seconds;\n}\n_s2(useTimer, \"mcG2hTHI4q8+uIAAnRxppoT2y1s=\");\nexport default MineSweeper;\nvar _c;\n$RefreshReg$(_c, \"MineSweeper\");","map":{"version":3,"names":["React","useReducer","useEffect","useState","sampleSize","Config","MinesweeperView","getInitState","difficulty","status","genGameConfig","reducer","state","action","type","payload","exclude","insertMines","ceils","indexes","autoCeils","forEach","i","ceil","index","newState","Error","map","minesAround","opening","getNearIndexes","rows","columns","MineSweeper","defaultDifficulty","onClose","dispatch","seconds","useTimer","changeCeilState","includes","openCeil","openCeils","nearCeils","filter","length","mineIndex","find","checkRemains","onReset","safeCeils","openingCeil","openingCeils","config","mines","Array","fill","_","originCeils","indexArray","keys","chosen","nearIndex","walked","walkCeils","reduce","lastIndexes","ceilIndex","row","Math","floor","column","arrayIndex","setSeconds","addSecond","sec","timer","setInterval","clearInterval"],"sources":["/Users/utils/misc/alexnicita.github.io/src/WinXP/apps/Minesweeper/index.js"],"sourcesContent":["import React, { useReducer, useEffect, useState } from 'react';\nimport sampleSize from 'lodash.samplesize';\n\nimport { Config } from './config';\nimport MinesweeperView from './MinesweeperView';\n\n// state: {\n//   difficulty: 'Beginner' || 'Intermediate' || 'Expert',\n//   status: 'new' || 'started' || 'died' || 'won',\n//   rows: Number,\n//   columns: Number,\n//   mines: Number,\n//   ceils: Array {\n//     state: 'cover' || 'flag' || 'unknown' || 'open' || 'die' || 'misflagged',\n//     minesAround: Number (negative for mine itself),\n//     opening: true || false\n//   }\n// }\n\nfunction getInitState(difficulty = 'Beginner') {\n  return {\n    difficulty,\n    status: 'new',\n    ...genGameConfig(Config[difficulty]),\n  };\n}\n\nfunction reducer(state, action = {}) {\n  switch (action.type) {\n    case 'CLEAR_MAP':\n      const difficulty = action.payload || state.difficulty;\n      return getInitState(difficulty);\n    case 'START_GAME':\n      const exclude = action.payload;\n      return {\n        ...state,\n        ...insertMines({ ...Config[state.difficulty], exclude }, state.ceils),\n        status: 'started',\n      };\n    case 'OPEN_CEIL': {\n      const indexes = autoCeils(state, action.payload);\n      const ceils = [...state.ceils];\n      indexes.forEach(i => {\n        const ceil = ceils[i];\n        ceils[i] = { ...ceil, state: 'open' };\n      });\n      return {\n        ...state,\n        ceils,\n      };\n    }\n    case 'CHANGE_CEIL_STATE': {\n      const index = action.payload;\n      const ceils = [...state.ceils];\n      const ceil = state.ceils[index];\n      let newState;\n      switch (ceil.state) {\n        case 'cover':\n          newState = 'flag';\n          break;\n        case 'flag':\n          newState = 'unknown';\n          break;\n        case 'unknown':\n          newState = 'cover';\n          break;\n        default:\n          throw new Error(`Unknown ceil state ${ceil.state}`);\n      }\n      ceils[index] = { ...ceil, state: newState };\n      return {\n        ...state,\n        ceils,\n      };\n    }\n    case 'GAME_OVER': {\n      const ceils = state.ceils.map(ceil => {\n        if (ceil.minesAround < 0 && ceil.state !== 'flag') {\n          return {\n            ...ceil,\n            state: 'mine',\n          };\n        } else if (ceil.state === 'flag' && ceil.minesAround >= 0) {\n          return {\n            ...ceil,\n            state: 'misflagged',\n          };\n        } else {\n          return {\n            ...ceil,\n            opening: false,\n          };\n        }\n      });\n      ceils[action.payload].state = 'die';\n      return {\n        ...state,\n        status: 'died',\n        ceils,\n      };\n    }\n    case 'WON': {\n      const ceils = state.ceils.map(ceil => {\n        if (ceil.minesAround >= 0) {\n          return {\n            ...ceil,\n            state: 'open',\n          };\n        } else {\n          return {\n            ...ceil,\n            state: 'flag',\n          };\n        }\n      });\n      return {\n        ...state,\n        status: 'won',\n        ceils,\n      };\n    }\n    case 'OPENING_CEIL': {\n      const ceil = state.ceils[action.payload];\n      const ceils = state.ceils.map(ceil => ({\n        ...ceil,\n        opening: false,\n      }));\n      ceils[action.payload] = { ...ceil, opening: true };\n      return {\n        ...state,\n        ceils,\n      };\n    }\n    case 'OPENING_CEILS': {\n      const indexes = getNearIndexes(action.payload, state.rows, state.columns);\n      const ceils = state.ceils.map(ceil => ({\n        ...ceil,\n        opening: false,\n      }));\n      [...indexes, action.payload].forEach(index => {\n        const ceil = { ...ceils[index] };\n        ceil.opening = true;\n        ceils[index] = ceil;\n      });\n      return {\n        ...state,\n        ceils,\n      };\n    }\n    default:\n      return state;\n  }\n}\n\nfunction MineSweeper({ defaultDifficulty, onClose }) {\n  const [state, dispatch] = useReducer(\n    reducer,\n    getInitState(defaultDifficulty),\n  );\n  const seconds = useTimer(state.status);\n  function changeCeilState(index) {\n    const ceil = state.ceils[index];\n    if (ceil.state === 'open' || ['won', 'died'].includes(state.status)) return;\n    dispatch({ type: 'CHANGE_CEIL_STATE', payload: index });\n  }\n  function openCeil(index) {\n    switch (state.status) {\n      case 'new':\n        dispatch({ type: 'START_GAME', payload: index });\n        dispatch({ type: 'OPEN_CEIL', payload: index });\n        break;\n      case 'started':\n        const ceil = state.ceils[index];\n        if (['flag', 'open'].includes(ceil.state)) {\n          break;\n        } else if (ceil.minesAround < 0) {\n          dispatch({ type: 'GAME_OVER', payload: index });\n        } else {\n          dispatch({ type: 'OPEN_CEIL', payload: index });\n        }\n        break;\n      default:\n      // console.log(state.status);\n    }\n  }\n  function openCeils(index) {\n    const ceil = state.ceils[index];\n    if (\n      ceil.state !== 'open' ||\n      ceil.minesAround <= 0 ||\n      state.status !== 'started'\n    )\n      return;\n    const indexes = getNearIndexes(index, state.rows, state.columns);\n    const nearCeils = indexes.map(i => state.ceils[i]);\n    if (\n      nearCeils.filter(ceil => ceil.state === 'flag').length !==\n      ceil.minesAround\n    )\n      return;\n    const mineIndex = indexes.find(\n      i => state.ceils[i].minesAround < 0 && state.ceils[i].state !== 'flag',\n    );\n    if (mineIndex) {\n      dispatch({ type: 'GAME_OVER', payload: mineIndex });\n    } else {\n      indexes.forEach(i => dispatch({ type: 'OPEN_CEIL', payload: i }));\n    }\n  }\n  useEffect(() => {\n    if (state.status === 'started' && checkRemains() === 0) {\n      dispatch({ type: 'WON' });\n    }\n  });\n  function onReset(difficulty) {\n    dispatch({ type: 'CLEAR_MAP', payload: difficulty });\n  }\n  function checkRemains() {\n    const safeCeils = state.ceils\n      .filter(ceil => ceil.state !== 'open')\n      .filter(ceil => ceil.minesAround >= 0);\n    return safeCeils.length;\n  }\n  function openingCeil(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({ type: 'OPENING_CEIL', payload: index });\n  }\n  function openingCeils(index) {\n    if (['died', 'won'].includes(state.status)) return;\n    dispatch({ type: 'OPENING_CEILS', payload: index });\n  }\n  return (\n    <MinesweeperView\n      {...state}\n      onClose={onClose}\n      changeCeilState={changeCeilState}\n      openCeil={openCeil}\n      openCeils={openCeils}\n      onReset={onReset}\n      seconds={seconds}\n      openingCeil={openingCeil}\n      openingCeils={openingCeils}\n    />\n  );\n}\n\nfunction genGameConfig(config) {\n  const { rows, columns, mines } = config;\n  const ceils = Array(rows * columns)\n    .fill()\n    .map(_ => ({\n      state: 'cover',\n      minesAround: 0,\n      opening: false,\n    }));\n  return {\n    rows,\n    columns,\n    ceils,\n    mines,\n  };\n}\n\nfunction insertMines(config, originCeils) {\n  const { rows, columns, mines, exclude } = config;\n  const ceils = originCeils.map(ceil => ({ ...ceil }));\n  if (rows * columns !== ceils.length)\n    throw new Error('rows and columns not equal to ceils');\n  const indexArray = [...Array(rows * columns).keys()];\n  sampleSize(\n    indexArray.filter(i => i !== exclude),\n    mines,\n  ).forEach(chosen => {\n    ceils[chosen].minesAround = -10;\n    getNearIndexes(chosen, rows, columns).forEach(nearIndex => {\n      ceils[nearIndex].minesAround += 1;\n    });\n  });\n  return {\n    rows,\n    columns,\n    ceils,\n    mines,\n  };\n}\n\nfunction autoCeils(state, index) {\n  const { rows, columns } = state;\n  const ceils = state.ceils.map(ceil => ({\n    ...ceil,\n    walked: false,\n  }));\n  return walkCeils(index);\n  function walkCeils(index) {\n    const ceil = ceils[index];\n    if (ceil.walked || ceil.minesAround < 0 || ceil.state === 'flag') return [];\n    ceil.walked = true;\n    if (ceil.minesAround > 0) return [index];\n    return [\n      index,\n      ...getNearIndexes(index, rows, columns).reduce(\n        (lastIndexes, ceilIndex) => {\n          return [...lastIndexes, ...walkCeils(ceilIndex)];\n        },\n        [],\n      ),\n    ];\n  }\n}\n\nfunction getNearIndexes(index, rows, columns) {\n  if (index < 0 || index >= rows * columns) return [];\n  const row = Math.floor(index / columns);\n  const column = index % columns;\n  return [\n    index - columns - 1,\n    index - columns,\n    index - columns + 1,\n    index - 1,\n    index + 1,\n    index + columns - 1,\n    index + columns,\n    index + columns + 1,\n  ].filter((_, arrayIndex) => {\n    if (row === 0 && arrayIndex < 3) return false;\n    if (row === rows - 1 && arrayIndex > 4) return false;\n    if (column === 0 && [0, 3, 5].includes(arrayIndex)) return false;\n    if (column === columns - 1 && [2, 4, 7].includes(arrayIndex)) return false;\n    return true;\n  });\n}\n\nfunction useTimer(status) {\n  const [seconds, setSeconds] = useState(0);\n  function addSecond() {\n    setSeconds(sec => sec + 1);\n  }\n  useEffect(() => {\n    let timer;\n    switch (status) {\n      case 'started':\n        timer = setInterval(addSecond, 1000);\n        break;\n      case 'new':\n        setSeconds(0);\n        break;\n      default:\n        break;\n    }\n    return () => clearInterval(timer);\n  }, [status]);\n  return seconds;\n}\n\nexport default MineSweeper;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}